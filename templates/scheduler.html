{% extends "base.html" %} {% block title %}Планировщик сообщений{% endblock %}
{% block content %}
<div class="row">
  <div class="col-12">
    <div class="d-flex justify-content-between align-items-center mb-4">
      <h2><i class="bi bi-clock"></i> Планировщик сообщений</h2>
      <div class="text-muted" id="currentDateTime">
        <i class="bi bi-calendar3"></i> <span id="dateDisplay"></span>
        <i class="bi bi-clock ms-2"></i> <span id="timeDisplay"></span>
      </div>
    </div>

    <div class="card mb-4">
      <div class="card-header">
        <i class="bi bi-plus-circle"></i> Создать новую задачу
      </div>
      <div class="card-body">
        <form id="scheduleForm" enctype="multipart/form-data">
          <div class="mb-3">
            <label for="scheduleMessage" class="form-label">Текст сообщения</label>
            <textarea class="form-control" id="scheduleMessage" rows="4" required></textarea>
          </div>

          <div class="mb-3">
            <label for="scheduleImages" class="form-label">Прикрепить изображения (необязательно, до 10 штук)</label>
            <input type="file" class="form-control" id="scheduleImages" accept="image/*" style="display: none;">
            <div class="d-flex gap-2 mb-2">
              <button type="button" class="btn btn-outline-primary" onclick="document.getElementById('scheduleImages').click()">
                <i class="bi bi-plus-circle"></i> Добавить изображение
              </button>
              <button type="button" class="btn btn-sm btn-danger" id="clearImagesBtn" style="display: none;" onclick="removeAllImages()">
                <i class="bi bi-x"></i> Удалить все
              </button>
            </div>
            <div id="imagePreview" class="mt-2 d-flex flex-wrap gap-2" style="display: none;"></div>
            <small class="text-muted" id="imagesCountInfo" style="display: none;"></small>
          </div>

          <div class="mb-3" id="imagePositionContainer" style="display: none;">
            <label class="form-label">Расположение изображений</label>
            <div class="d-flex flex-column gap-2">
              <div class="form-check">
                <input class="form-check-input" type="radio" name="imagePosition" id="imagePositionTop" value="top" checked>
                <label class="form-check-label" for="imagePositionTop">
                  <i class="bi bi-image me-1"></i> Подпись снизу
                  <small class="text-muted d-block">Стандартное расположение: картинка сверху, текст под ней</small>
                </label>
              </div>
              <div class="form-check">
                <input class="form-check-input" type="radio" name="imagePosition" id="imagePositionTopInverted" value="top_inverted">
                <label class="form-check-label" for="imagePositionTopInverted">
                  <i class="bi bi-card-text me-1"></i> Подпись сверху
                  <small class="text-muted d-block">Переместить подпись наверх: текст над картинкой</small>
                </label>
              </div>
            </div>
          </div>

          <div class="mb-3">
            <label class="form-label">Даты и время отправки</label>
            <div id="scheduledTimes">
              <div class="scheduled-time-row mb-2">
                <div class="input-group">
                  <input type="datetime-local" class="form-control scheduled-datetime" required>
                  <button type="button" class="btn btn-outline-danger remove-time-btn" style="display: none;">
                    <i class="bi bi-trash"></i>
                  </button>
                </div>
              </div>
            </div>
            <button type="button" class="btn btn-outline-primary btn-sm mt-2" onclick="addScheduledTime()">
              <i class="bi bi-plus-circle"></i> Добавить еще дату
            </button>
          </div>

          <div class="mb-3">
            <label class="form-label">Получатели</label>
            <div id="recipientsInfoEmpty" style="display: block;">
              <span class="text-muted">
                <i class="bi bi-info-circle"></i> Выберите получателей на странице контактов или
                <a href="{{ url_for('contacts') }}">перейдите туда</a>
              </span>
            </div>
            
            <div id="recipientsInfoSelected" style="display: none;">
              <div class="d-flex justify-content-between align-items-center mb-2">
                <span class="text-muted" id="schedulerRecipientsHeader" style="cursor: pointer;" onclick="toggleSchedulerRecipientsList(event)">
                  Выбрано получателей: <strong id="schedulerRecipientsCount">0</strong>
                  <i class="bi bi-chevron-down ms-1" id="schedulerRecipientsArrow"></i>
                </span>
              </div>
              
              <div id="schedulerRecipientsList" class="mt-2 p-3 bg-light border rounded" style="display: none;">
                <div class="d-flex justify-content-between align-items-center mb-2">
                  <h6 class="mb-0"><i class="bi bi-people-fill"></i> Список выбранных</h6>
                  <button type="button" class="btn btn-sm btn-outline-danger" onclick="clearSchedulerSelected()">
                    <i class="bi bi-trash"></i> Очистить всех
                  </button>
                </div>
                <div id="schedulerRecipientsContent" class="d-flex flex-wrap gap-2" style="max-height: 250px; overflow-y: auto;">
                </div>
              </div>
            </div>
            <input type="hidden" id="scheduleRecipients" />
          </div>

          <button type="submit" class="btn btn-success" id="createTaskBtn">
            <i class="bi bi-check-circle"></i> Создать задачу
          </button>
        </form>
      </div>
    </div>

    <div class="card mb-4">
      <div class="card-header d-flex justify-content-between align-items-center">
        <span><i class="bi bi-list-task"></i> Активные задачи</span>
        <div class="d-flex align-items-center gap-2">
          <div class="form-check mb-0">
            <input class="form-check-input" type="checkbox" id="autoUpdateActiveCheckbox" checked onchange="toggleAutoUpdate('active')">
            <label class="form-check-label" for="autoUpdateActiveCheckbox">
              Авто-обновление
            </label>
          </div>
          <button class="btn btn-sm btn-outline-primary" onclick="loadTasks()">
            <i class="bi bi-arrow-clockwise"></i> Обновить
          </button>
        </div>
      </div>
      <div class="card-body">
        <div id="tasksList">
          <div class="text-center py-5">
            <div class="spinner-border text-primary" role="status">
              <span class="visually-hidden">Загрузка...</span>
            </div>
            <p class="mt-3 text-muted">Загрузка задач...</p>
          </div>
        </div>
      </div>
    </div>

    <div class="card">
      <div class="card-header d-flex justify-content-between align-items-center">
        <span><i class="bi bi-check2-circle"></i> Выполненные задачи</span>
        <div class="d-flex align-items-center gap-2">
          <div class="form-check mb-0">
            <input class="form-check-input" type="checkbox" id="autoUpdateCompletedCheckbox" checked onchange="toggleAutoUpdate('completed')">
            <label class="form-check-label" for="autoUpdateCompletedCheckbox">
              Авто-обновление
            </label>
          </div>
          <button class="btn btn-sm btn-outline-success" onclick="loadCompletedTasks()">
            <i class="bi bi-arrow-clockwise"></i> Обновить
          </button>
        </div>
      </div>
      <div class="card-body">
        <div id="completedTasksList">
          <div class="text-center py-5">
            <div class="spinner-border text-success" role="status">
              <span class="visually-hidden">Загрузка...</span>
            </div>
            <p class="mt-3 text-muted">Загрузка выполненных задач...</p>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Modal for Slot Details -->
<div class="modal fade" id="slotDetailsModal" tabindex="-1">
  <div class="modal-dialog modal-lg">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Детали слота</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
      </div>
      <div class="modal-body">
        <!-- Информация о слоте -->
        <div class="mb-3">
          <p class="mb-1"><strong>Статус:</strong> <span id="slotStatus"></span></p>
          <p class="mb-1"><strong>Время:</strong> <span id="slotDateTime"></span></p>
          <p class="mb-1"><strong>Прогресс:</strong> <span id="slotProgress"></span></p>
        </div>
        
        <!-- Фильтры по статусу -->
        <div class="mb-3">
          <label class="fw-bold mb-2">Фильтр по статусу:</label>
          <div class="btn-group btn-group-sm" role="group">
            <button type="button" class="btn btn-outline-secondary active" data-filter="all">
              Все (<span id="countAll">0</span>)
            </button>
            <button type="button" class="btn btn-outline-success" data-filter="sent">
              ✅ Успешно (<span id="countSent">0</span>)
            </button>
            <button type="button" class="btn btn-outline-danger" data-filter="failed">
              ❌ Ошибка (<span id="countFailed">0</span>)
            </button>
            <button type="button" class="btn btn-outline-warning" data-filter="pending">
              ⏳ Ожидает (<span id="countPending">0</span>)
            </button>
            <button type="button" class="btn btn-outline-secondary" data-filter="cancelled">
              ⭕ Отменено (<span id="countCancelled">0</span>)
            </button>
          </div>
        </div>
        
        <!-- Таблица с получателями -->
        <div class="table-responsive">
          <table class="table table-sm table-hover">
            <thead>
              <tr>
                <th>Получатель</th>
                <th>Статус</th>
                <th>Время отправки</th>
                <th>Примечание</th>
              </tr>
            </thead>
            <tbody id="recipientsTable">
              <tr>
                <td colspan="4" class="text-center text-muted">Загрузка...</td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Закрыть</button>
      </div>
    </div>
  </div>
</div>

{% endblock %} 

{% block extra_js %}
<script>
  // State management
  let schedulerSelectedImages = [];
  let schedulerSelectedImagesData = [];
  let schedulerSelectedRecipients = [];
  let schedulerTimeSlots = [];
  let schedulerGroupTopics = {};
  let schedulerCurrentTopicGroupId = null;

  // Auto-refresh state
  let activeTasksInterval = null;
  let completedTasksInterval = null;
  let activeRefreshIntervalMs = 2000;  // default value
  let completedRefreshIntervalMs = 5000; // default value

  document.addEventListener("DOMContentLoaded", function () {
    startDateTimeUpdater('dateDisplay', 'timeDisplay');

    // 1. Сначала восстанавливаем данные из sessionStorage
    const savedMessage = sessionStorage.getItem("scheduledMessage");
    const savedRecipients = sessionStorage.getItem("scheduledRecipients");
    const savedRecipientsInfo = sessionStorage.getItem("scheduledRecipientsInfo");
    const savedImagesData = sessionStorage.getItem("scheduledImagesData");

    if (savedMessage) {
      document.getElementById("scheduleMessage").value = savedMessage;
    }

    if (savedRecipients && savedRecipientsInfo) {
      try {
        const recipients = JSON.parse(savedRecipients);
        const recipientsInfo = JSON.parse(savedRecipientsInfo);

        if (recipients.length > 0) {
          document.getElementById("scheduleRecipients").value = savedRecipients;
          window.schedulerRecipientsInfo = recipientsInfo;

          document.getElementById("recipientsInfoEmpty").style.display = 'none';
          document.getElementById("recipientsInfoSelected").style.display = 'block';
          document.getElementById("schedulerRecipientsCount").textContent = recipients.length;

          // Важно: Список скрыт по умолчанию, но мы его наполняем
          updateSchedulerRecipientsList();

          // Раскрываем список сразу, чтобы пользователь видел результат
          const listDiv = document.getElementById("schedulerRecipientsList");
          const arrow = document.getElementById("schedulerRecipientsArrow");
          if (listDiv && arrow) {
            listDiv.style.display = 'block';
            arrow.className = 'bi bi-chevron-up ms-1';
          }
        }
      } catch (e) {
        console.error("Error parsing recipients from session:", e);
      }
    }

    if (savedImagesData) {
      try {
        const imagesInfo = JSON.parse(savedImagesData);
        imagesInfo.forEach(imgInfo => {
          const byteString = atob(imgInfo.data.split(',')[1]);
          const mimeString = imgInfo.data.split(',')[0].split(':')[1].split(';')[0];
          const ab = new ArrayBuffer(byteString.length);
          const ia = new Uint8Array(ab);
          for (let i = 0; i < byteString.length; i++) {
            ia[i] = byteString.charCodeAt(i);
          }
          const blob = new Blob([ab], { type: mimeString });
          const file = new File([blob], imgInfo.name, { type: mimeString });
          schedulerSelectedImages.push(file);
          schedulerSelectedImagesData.push(imgInfo.data);
        });
        updateSchedulerImagesPreview();
      } catch (err) {
        console.error("Error restoring images:", err);
      }
    }

    // Initialize time slots with proper minimum time
    const defaultDateTime = getDefaultDateTimeString();

    document.querySelector('.scheduled-datetime').value = defaultDateTime;
    // Браузерная валидация удалена, используем только JavaScript валидацию

    loadTasks();
    loadCompletedTasks();
    
    // Start auto-refresh after initial load
    setTimeout(() => {
      toggleAutoUpdate('active');
      toggleAutoUpdate('completed');
    }, 500);
  });

  // Cleanup intervals on page unload
  window.addEventListener('beforeunload', function() {
    if (activeTasksInterval) clearInterval(activeTasksInterval);
    if (completedTasksInterval) clearInterval(completedTasksInterval);
  });

  /**
   * Returns the minimum allowed datetime string (current time + 5 seconds, rounded up to next minute)
   * Format: YYYY-MM-DDTHH:MM
   */
  function getMinDateTimeString() {
    const now = new Date();
    // Add 5 seconds buffer for processing time
    now.setSeconds(now.getSeconds() + 5);

    const year = now.getFullYear();
    const month = String(now.getMonth() + 1).padStart(2, '0');
    const day = String(now.getDate()).padStart(2, '0');
    const hours = String(now.getHours()).padStart(2, '0');
    const minutes = String(now.getMinutes()).padStart(2, '0');

    return `${year}-${month}-${day}T${hours}:${minutes}`;
  }

  /**
   * Returns the default datetime string (current time + 5 minutes)
   * Format: YYYY-MM-DDTHH:MM
   */
  function getDefaultDateTimeString() {
    const now = new Date();
    now.setMinutes(now.getMinutes() + 5);

    const year = now.getFullYear();
    const month = String(now.getMonth() + 1).padStart(2, '0');
    const day = String(now.getDate()).padStart(2, '0');
    const hours = String(now.getHours()).padStart(2, '0');
    const minutes = String(now.getMinutes()).padStart(2, '0');

    return `${year}-${month}-${day}T${hours}:${minutes}`;
  }

  /**
   * Validates that a scheduled time is at least 5 seconds in the future
   * Returns { valid: boolean, currentTime: string, message: string }
   */
  function validateScheduledTime(dateTimeString) {
    const now = new Date();
    now.setSeconds(now.getSeconds() + 5); // Add 5 second buffer

    const scheduledTime = new Date(dateTimeString);

    if (scheduledTime < now) {
      const currentTimeStr = now.toLocaleString('ru-RU', {
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit'
      });
      return {
        valid: false,
        currentTime: currentTimeStr,
        message: `Время отправки должно быть в будущем. Текущее время: ${currentTimeStr}`
      };
    }

    return { valid: true };
  }

  document.getElementById('scheduleImages').addEventListener('change', function(e) {
    const files = Array.from(e.target.files);
    
    files.forEach(file => {
      if (schedulerSelectedImages.length >= 10) return;
      
      const reader = new FileReader();
      reader.onload = function(event) {
        schedulerSelectedImages.push(file);
        schedulerSelectedImagesData.push(event.target.result);
        updateSchedulerImagesPreview();
      };
      reader.readAsDataURL(file);
    });
    
    e.target.value = '';
  });

  function updateSchedulerImagesPreview() {
    const previewContainer = document.getElementById('imagePreview');
    const clearBtn = document.getElementById('clearImagesBtn');
    const countInfo = document.getElementById('imagesCountInfo');
    const positionContainer = document.getElementById('imagePositionContainer');
    previewContainer.innerHTML = '';
    
    if (schedulerSelectedImages.length > 0) {
      previewContainer.style.display = 'flex';
      clearBtn.style.display = 'block';
      countInfo.style.display = 'block';
      positionContainer.style.display = 'block';
      countInfo.textContent = `Выбрано изображений: ${schedulerSelectedImages.length}/10`;
      
      schedulerSelectedImagesData.forEach((dataUrl, index) => {
        const imgWrapper = document.createElement('div');
        imgWrapper.className = 'position-relative';
        imgWrapper.innerHTML = `
          <img src="${dataUrl}" alt="Preview ${index + 1}" style="max-width: 100px; max-height: 100px;" class="rounded border">
          <span class="position-absolute top-0 start-100 translate-middle badge rounded-pill bg-primary">${index + 1}</span>
          <button type="button" class="btn btn-sm btn-danger position-absolute bottom-0 start-50 translate-middle-x" style="padding: 0.1rem 0.3rem; font-size: 0.7rem;" onclick="removeSchedulerImage(${index})">
            <i class="bi bi-x"></i>
          </button>
        `;
        previewContainer.appendChild(imgWrapper);
      });
    } else {
      previewContainer.style.display = 'none';
      clearBtn.style.display = 'none';
      countInfo.style.display = 'none';
      positionContainer.style.display = 'none';
    }
  }

  function removeSchedulerImage(index) {
    schedulerSelectedImages.splice(index, 1);
    schedulerSelectedImagesData.splice(index, 1);
    updateSchedulerImagesPreview();
  }

  function removeAllImages() {
    schedulerSelectedImages = [];
    schedulerSelectedImagesData = [];
    document.getElementById('scheduleImages').value = '';
    updateSchedulerImagesPreview();
  }

  function addScheduledTime() {
    const container = document.getElementById('scheduledTimes');
    const defaultDateTime = getDefaultDateTimeString();
    const minDateTime = getMinDateTimeString();

    const newRow = document.createElement('div');
    newRow.className = 'scheduled-time-row mb-2';
    newRow.innerHTML = `
      <div class="input-group">
        <input type="datetime-local" class="form-control scheduled-datetime" value="${defaultDateTime}" min="${minDateTime}" required>
        <button type="button" class="btn btn-outline-danger remove-time-btn" onclick="removeScheduledTime(this)">
          <i class="bi bi-trash"></i>
        </button>
      </div>
    `;
    container.appendChild(newRow);

    updateRemoveButtons();
  }

  function removeScheduledTime(btn) {
    btn.closest('.scheduled-time-row').remove();
    updateRemoveButtons();
  }

  function updateRemoveButtons() {
    const rows = document.querySelectorAll('.scheduled-time-row');
    rows.forEach((row, index) => {
      const btn = row.querySelector('.remove-time-btn');
      if (btn) {
        btn.style.display = rows.length > 1 ? 'block' : 'none';
      }
    });
  }

  function getScheduledTimes() {
    const inputs = document.querySelectorAll('.scheduled-datetime');
    const times = [];
    inputs.forEach(input => {
      if (input.value) {
        times.push(input.value);
      }
    });
    return times;
  }

  // Комплексная валидация перед отправкой
  function validateScheduleFormComprehensive() {
    const message = document.getElementById("scheduleMessage").value.trim();
    if (!message) {
      showAlert("Введите текст сообщения", "warning");
      return false;
    }
    if (message.length > 4096) {
      showAlert("Сообщение слишком длинное (максимум 4096 символов)", "warning");
      return false;
    }

    const recipientsStr = document.getElementById("scheduleRecipients").value;
    if (!recipientsStr) {
      showAlert("Выберите получателей на странице контактов", "warning");
      return false;
    }

    try {
      const recipients = JSON.parse(recipientsStr);
      if (!Array.isArray(recipients) || recipients.length === 0) {
        showAlert("Выберите хотя бы одного получателя", "warning");
        return false;
      }
    } catch (e) {
      showAlert("Ошибка в данных получателей", "warning");
      return false;
    }

    const inputs = document.querySelectorAll('.scheduled-datetime');
    if (inputs.length === 0) {
      showAlert("Добавьте хотя бы одну дату и время отправки", "warning");
      return false;
    }

    const now = new Date();
    const minTime = new Date(now.getTime() + 5000);

    for (let i = 0; i < inputs.length; i++) {
      const value = (inputs[i].value || '').trim();
      if (!value) {
        showAlert(`Слот ${i + 1}: укажите дату и время`, "warning");
        return false;
      }

      const selectedDateTime = new Date(value + ':00');
      if (isNaN(selectedDateTime.getTime())) {
        showAlert(`Слот ${i + 1}: некорректный формат времени "${value}"`, "warning");
        return false;
      }

      if (selectedDateTime < minTime) {
        const currentTime = now.toLocaleTimeString('ru-RU', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
        const minTimeStr = minTime.toLocaleTimeString('ru-RU', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
        showAlert(
          `Слот ${i + 1}: время в прошлом. Текущее: ${currentTime}. Минимум: ${minTimeStr} (текущий момент + 5 сек)`,
          "danger"
        );
        return false;
      }
    }

    return true;
  }

  document.getElementById("scheduleForm").addEventListener("submit", async function (e) {
    e.preventDefault();

    if (!validateScheduleFormComprehensive()) {
      return;
    }

    const message = document.getElementById("scheduleMessage").value.trim();
    const recipientsStr = document.getElementById("scheduleRecipients").value;
    const scheduledTimes = getScheduledTimes();

    const createBtn = document.getElementById("createTaskBtn");
    createBtn.disabled = true;
    createBtn.innerHTML = '<span class="spinner-border spinner-border-sm me-2"></span>Создание...';

    try {
      const formData = new FormData();
      formData.append('message', message);
      formData.append('recipients', recipientsStr);
      formData.append('scheduled_times', JSON.stringify(scheduledTimes));
      formData.append('tz_offset', String(-new Date().getTimezoneOffset()));

      if (window.schedulerRecipientsInfo) {
        formData.append('recipients_info', JSON.stringify(window.schedulerRecipientsInfo));
      }

      schedulerSelectedImages.forEach(file => {
        formData.append('images[]', file);
      });

      const imagePosition = document.querySelector('input[name="imagePosition"]:checked');
      if (imagePosition && schedulerSelectedImages.length > 0) {
        formData.append('image_position', imagePosition.value);
      }

      const response = await fetch("/api/scheduler/create", {
        method: "POST",
        body: formData
      });

      const contentType = response.headers.get('content-type') || '';
      if (!contentType.includes('application/json')) {
        const text = await response.text();
        console.error(`Unexpected response type: ${contentType}. Status: ${response.status}`);
        console.error(text.substring(0, 1000));
        showAlert("Ошибка сервера. Пожалуйста, попробуйте позже или обратитесь в поддержку.", "danger");
        return;
      }

      const data = await response.json();

      if (data.success) {
        showAlert("Задача успешно создана! ID: #" + data.task_id, "success");

        document.getElementById("scheduleMessage").value = "";
        sessionStorage.removeItem("scheduledMessage");

        const recipientsInput = document.getElementById("scheduleRecipients");
        if (recipientsInput) recipientsInput.value = "";
        sessionStorage.removeItem("scheduledRecipients");
        sessionStorage.removeItem("scheduledRecipientsInfo");

        document.getElementById("recipientsInfoEmpty").style.display = 'block';
        document.getElementById("recipientsInfoSelected").style.display = 'none';
        document.getElementById("schedulerRecipientsList").style.display = 'none';
        document.getElementById("schedulerRecipientsArrow").className = 'bi bi-chevron-down ms-1';

        removeAllImages();
        sessionStorage.removeItem("scheduledImagesData");
        window.schedulerRecipientsInfo = null;

        // Reset time slots to default values
        const defaultDateTime = getDefaultDateTimeString();
        const minDateTime = getMinDateTimeString();

        const container = document.getElementById('scheduledTimes');
        if (container) {
          container.innerHTML = `
            <div class="scheduled-time-row mb-2">
              <div class="input-group">
                <input type="datetime-local" class="form-control scheduled-datetime" value="${defaultDateTime}" min="${minDateTime}" required>
                <button type="button" class="btn btn-outline-danger remove-time-btn" style="display: none;">
                  <i class="bi bi-trash"></i>
                </button>
              </div>
            </div>
          `;
        }

        loadTasks();
      } else {
        showAlert("Ошибка: " + (data.error || "Неизвестная ошибка"), "danger");
        console.error("API returned error:", data);
      }
    } catch (error) {
      console.error("Exception creating task:", error);
      showAlert("Ошибка создания задачи: " + error.message, "danger");
    } finally {
      createBtn.disabled = false;
      createBtn.innerHTML = '<i class="bi bi-check-circle"></i> Создать задачу';
    }
  });

  function renderRecipientsStatus(recipientsInfo, isCompleted = false, taskSlots = null) {
    if (!recipientsInfo || !recipientsInfo.length) return '<p class="text-muted small mb-0">Список получателей пуст</p>';
    
    let html = '<div class="list-group list-group-flush">';
    recipientsInfo.forEach(r => {
      let icon = 'bi-clock-history';
      let color = 'text-secondary';
      let statusLabel = 'Ожидает';
      
      // The API returns recipient status in 'status' field
      // We check for 'status' or fall back to 'pending'
      let status = r.status || 'pending';
      const error = r.error || null;
      const name = r.name || r.id || r.recipient_id || 'Unknown';
      
      // Smart switching logic for active tasks (50% time between slots)
      if (!isCompleted && taskSlots && taskSlots.length > 0) {
        // Find current executing or completed slot
        const currentSlotIndex = taskSlots.findIndex(s => s.status === 'executing');
        let checkSlotIndex = currentSlotIndex;
        
        // If no executing slot, find the last completed slot
        if (checkSlotIndex === -1) {
          for (let i = taskSlots.length - 1; i >= 0; i--) {
            if (taskSlots[i].status === 'completed') {
              checkSlotIndex = i;
              break;
            }
          }
        }
        
        // If we have a completed slot and there's a next slot
        if (checkSlotIndex !== -1 && checkSlotIndex < taskSlots.length - 1) {
          const currentSlot = taskSlots[checkSlotIndex];
          const nextSlot = taskSlots[checkSlotIndex + 1];
          
          if (currentSlot.status === 'completed' && nextSlot) {
            const currentSlotTime = new Date(currentSlot.datetime).getTime();
            const nextSlotTime = new Date(nextSlot.datetime).getTime();
            const timeDiff = nextSlotTime - currentSlotTime;
            const midTime = currentSlotTime + (timeDiff / 2);
            const now = Date.now();
            
            // If we're past the midpoint, show "Ожидает" status
            if (now > midTime && status === 'sent') {
              status = 'pending';
            }
          }
        }
      }
      
      if (status === 'sent') {
        icon = 'bi-check-circle-fill';
        color = 'text-success';
        statusLabel = 'Отправлено';
      } else if (status === 'failed') {
        icon = 'bi-exclamation-circle-fill';
        color = 'text-danger';
        statusLabel = 'Ошибка';
      } else if (status === 'cancelled') {
        icon = 'bi-x-circle-fill';
        color = 'text-warning';
        statusLabel = 'Отменено';
      }
      
      const errorText = error ? ` — ${error}` : '';
      
      // Get slot info and statistics from recipient data
      const currentSlotIndex = r.current_slot_index || null;
      const totalSlots = r.total_slots || null;
      const sentCount = r.sent_count || 0;
      const errorCount = r.error_count || 0;
      const cancelledCount = r.cancelled_count || 0;
      
      let slotInfo = '';
      if (currentSlotIndex && totalSlots) {
        slotInfo = `<span class="text-muted">Слот ${currentSlotIndex}/${totalSlots} [${sentCount}/${errorCount}/${cancelledCount}]</span>`;
      }
      
      html += `
        <div class="list-group-item bg-transparent d-flex justify-content-between align-items-center py-1 px-0 border-0 small">
          <span class="text-truncate" style="max-width: 250px;">
            <i class="bi ${icon} ${color} me-2" title="${statusLabel}${errorText}"></i>
            <strong>${UIUtils.escapeHtml(name)}</strong> — <span class="${color}">${statusLabel}${UIUtils.escapeHtml(errorText)}</span>
          </span>
          ${slotInfo}
        </div>
      `;
    });
    html += '</div>';
    return html;
  }

  async function loadTasks() {
    try {
      const response = await fetch("/api/scheduler/tasks");
      const data = await response.json();

      if (data.success) {
        // Update refresh interval if provided
        if (data.refresh_interval_ms) {
          activeRefreshIntervalMs = data.refresh_interval_ms;
        }
        displayTasks(data.tasks);
      } else {
        showAlert("Ошибка загрузки задач: " + data.error, "danger");
      }
    } catch (error) {
      showAlert("Ошибка загрузки задач: " + error.message, "danger");
    }
  }

  function displayTasks(tasks) {
    const container = document.getElementById("tasksList");

    if (tasks.length === 0) {
      container.innerHTML = '<p class="text-center text-muted py-5">Нет активных задач</p>';
      return;
    }

    let html = '<div class="accordion" id="tasksAccordion">';

    tasks.forEach((task, index) => {
      const messagePreview = task.message_text.length > 50 
        ? task.message_text.substring(0, 50) + "..." 
        : task.message_text;

      const tgAccount = task.telegram_account || 'Неизвестно';
      const recipientsHtml = renderRecipientsStatus(task.recipients_info, false, task.slots);
      
      let slotsHtml = '';
      if (task.slots && task.slots.length > 0) {
        task.slots.forEach(slot => {
          const date = TimezoneManager.formatLocalDateTime(slot.datetime);
          const progressWidth = slot.percentage || 0;
          let statusBadge = '';
          
          switch(slot.status) {
            case 'pending': statusBadge = '<span class="badge bg-secondary">Ожидает</span>'; break;
            case 'executing': statusBadge = '<span class="badge bg-primary">Выполняется</span>'; break;
            case 'completed': statusBadge = '<span class="badge bg-success">Завершено</span>'; break;
            case 'cancelled': statusBadge = '<span class="badge bg-warning text-dark">Отменено</span>'; break;
            case 'failed': statusBadge = '<span class="badge bg-danger">Ошибка</span>'; break;
            default: statusBadge = `<span class="badge bg-info">${slot.status}</span>`;
          }

          slotsHtml += `
            <div class="mb-3 p-2 border-bottom slot-item" data-slot-id="${slot.id}" style="cursor: pointer; transition: background-color 0.2s;" 
                 onmouseover="this.style.backgroundColor='#f8f9fa'" 
                 onmouseout="this.style.backgroundColor='transparent'"
                 onclick="openSlotDetails(${slot.id})">
              <div class="d-flex justify-content-between align-items-center mb-1">
                <small class="text-muted">${date}</small>
                ${statusBadge}
              </div>
              <div class="progress" style="height: 10px;">
                <div class="progress-bar progress-bar-striped ${slot.status === 'executing' ? 'progress-bar-animated' : ''}" 
                     role="progressbar" style="width: ${progressWidth}%"></div>
              </div>
              <div class="d-flex justify-content-between mt-1">
                <small class="text-muted">Прогресс: ${slot.processed}/${slot.total}</small>
                <small class="fw-bold">${progressWidth}%</small>
              </div>
            </div>
          `;
        });
      } else {
        slotsHtml = '<p class="text-muted small">Нет запланированных слотов</p>';
      }

      html += `
        <div class="accordion-item">
          <h2 class="accordion-header">
            <button class="accordion-button ${index > 0 ? 'collapsed' : ''}" type="button" data-bs-toggle="collapse" data-bs-target="#task${task.id}">
              <div class="d-flex justify-content-between align-items-center w-100 me-3">
                <span>
                  <strong>#${task.display_id || task.id}</strong> - ${escapeHtml(messagePreview)}
                  ${task.has_image ? '<i class="bi bi-image text-primary ms-2"></i>' : ''}
                  <span class="ms-2 badge bg-info text-dark" style="font-size: 0.7rem;">
                    <i class="bi bi-person"></i> ${tgAccount}
                  </span>
                </span>
              </div>
            </button>
          </h2>
          <div id="task${task.id}" class="accordion-collapse collapse ${index === 0 ? 'show' : ''}" data-bs-parent="#tasksAccordion">
            <div class="accordion-body">
              <div class="mb-3">
                <h6><i class="bi bi-clock-history"></i> Слоты рассылки:</h6>
                ${slotsHtml}
                
                <h6 class="mt-3"><i class="bi bi-chat-dots"></i> Текст сообщения:</h6>
                <div class="p-2 bg-light border rounded mb-3" style="white-space: pre-wrap; font-size: 0.9rem;">${escapeHtml(task.message_text)}</div>
                
                <h6 class="mt-3"><i class="bi bi-people"></i> Статус получателей:</h6>
                <div class="recipients-status-list border rounded p-2 bg-light mb-3" style="max-height: 200px; overflow-y: auto;">
                  ${recipientsHtml}
                </div>
              </div>
              <div class="d-flex justify-content-end gap-2">
                <button class="btn btn-sm btn-outline-danger" onclick="cancelTask(${task.id})">
                  <i class="bi bi-x-circle"></i> Отменить задачу
                </button>
              </div>
            </div>
          </div>
        </div>
      `;
    });

    html += '</div>';
    container.innerHTML = html;
  }

  async function cancelTask(taskId) {
    if (!confirm("Вы уверены, что хотите отменить эту задачу? Рассылка прекратится немедленно.")) return;

    try {
      const response = await fetch(`/api/scheduler/task/${taskId}/cancel`, {
        method: "POST",
        headers: {
          'X-CSRF-Token': ApiClient.getCsrfToken(),
          'Content-Type': 'application/json'
        }
      });
      const data = await response.json();

      // Check for success flag OR valid status values
      if (data.success || data.status === "cancelled" || data.status === "already_cancelled") {
        if (data.status === "already_cancelled") {
          showAlert("Задача уже была отменена", "info");
        } else {
          showAlert("Задача отменена", "info");
        }
        loadTasks();
      } else {
        showAlert("Ошибка: " + (data.error || "Неизвестная ошибка"), "danger");
      }
    } catch (error) {
      showAlert("Ошибка сети", "danger");
    }
  }

  async function deleteTask(taskId) {
    if (!confirm("Удалить эту задачу?")) {
      return;
    }

    try {
      const response = await fetch(`/api/scheduler/delete/${taskId}`, {
        method: "DELETE",
        headers: {
          'X-CSRF-Token': ApiClient.getCsrfToken()
        }
      });

      const data = await response.json();

      if (data.success) {
        showAlert("Задача удалена", "success");
        
        // Remove from Active Tasks UI
        const taskElement = document.getElementById(`task${taskId}`);
        if (taskElement) {
          const accordionItem = taskElement.closest('.accordion-item');
          if (accordionItem) accordionItem.remove();
        }
        
        // Remove from Completed Tasks UI
        const compTaskElement = document.getElementById(`compTask${taskId}`);
        if (compTaskElement) {
          const accordionItem = compTaskElement.closest('.accordion-item');
          if (accordionItem) accordionItem.remove();
        }
        
        // Refresh lists if empty
        const activeContainer = document.getElementById("tasksList");
        if (activeContainer && activeContainer.querySelectorAll('.accordion-item').length === 0) {
          activeContainer.innerHTML = '<p class="text-center text-muted py-5">Нет активных задач</p>';
        }
        
        const completedContainer = document.getElementById("completedTasksList");
        if (completedContainer && completedContainer.querySelectorAll('.accordion-item').length === 0) {
          completedContainer.innerHTML = '<p class="text-center text-muted py-5">Нет выполненных задач</p>';
        }

      } else {
        showAlert("Ошибка: " + data.error, "danger");
      }
    } catch (error) {
      showAlert("Ошибка удаления задачи: " + error.message, "danger");
    }
  }

  function formatDate(dateString) {
    return TimezoneManager.formatLocalDateTime(dateString);
  }

  function renderTimeSlots(slots) {
    if (!slots || slots.length === 0) return '';
    let html = '<p><strong>Даты отправки:</strong></p><ul class="list-group list-group-flush">';
    slots.forEach(function(slot) {
      const itemClass = slot.is_sent ? (slot.has_error ? 'list-group-item-danger' : 'list-group-item-success') : 'list-group-item-secondary';
      const badge = slot.is_sent 
        ? (slot.has_error ? '<span class="badge bg-danger float-end">Ошибка</span>' : '<span class="badge bg-success float-end">Отправлено</span>')
        : '<span class="badge bg-secondary float-end">Не отправлено</span>';
      
      const dateVal = slot.datetime || slot.scheduled_datetime || slot.scheduled_at;
      html += '<li class="list-group-item d-flex justify-content-between align-items-center">' + 
              '<span>' + formatDate(dateVal) + '</span>' + badge + '</li>';
    });
    html += '</ul>';
    return html;
  }

  function toggleSchedulerRecipientsList(e) {
    if (e) {
      e.preventDefault();
      e.stopPropagation();
    }
    
    const listDiv = document.getElementById("schedulerRecipientsList");
    const arrow = document.getElementById("schedulerRecipientsArrow");
    
    if (!arrow || !listDiv) return;
    
    if (listDiv.style.display === 'none') {
      listDiv.style.display = 'block';
      arrow.className = 'bi bi-chevron-up ms-1';
    } else {
      listDiv.style.display = 'none';
      arrow.className = 'bi bi-chevron-down ms-1';
    }
  }
  
  function updateSchedulerRecipientsList() {
    const content = document.getElementById("schedulerRecipientsContent");
    const recipientsInfo = window.schedulerRecipientsInfo;
    
    if (!content) return;
    
    content.innerHTML = renderRecipientBadges(recipientsInfo, 'removeSchedulerRecipient');
  }

  function removeSchedulerRecipient(index) {
    if (!window.schedulerRecipientsInfo) return;
    
    window.schedulerRecipientsInfo.splice(index, 1);
    
    // Update IDs array too
    const recipientsIds = window.schedulerRecipientsInfo.map(r => r.id);
    
    // Sync with session storage
    sessionStorage.setItem("scheduledRecipients", JSON.stringify(recipientsIds));
    sessionStorage.setItem("scheduledRecipientsInfo", JSON.stringify(window.schedulerRecipientsInfo));
    
    document.getElementById("scheduleRecipients").value = JSON.stringify(recipientsIds);
    document.getElementById("schedulerRecipientsCount").textContent = window.schedulerRecipientsInfo.length;
    
    if (window.schedulerRecipientsInfo.length === 0) {
      document.getElementById("recipientsInfoEmpty").style.display = 'block';
      document.getElementById("recipientsInfoSelected").style.display = 'none';
      document.getElementById("schedulerRecipientsList").style.display = 'none';
    } else {
      updateSchedulerRecipientsList();
    }
  }

  function clearSchedulerSelected() {
    if (!confirm('Вы уверены, что хотите очистить список получателей?')) return;
    
    window.schedulerRecipientsInfo = [];
    sessionStorage.removeItem("scheduledRecipients");
    sessionStorage.removeItem("scheduledRecipientsInfo");
    
    document.getElementById("scheduleRecipients").value = "";
    document.getElementById("schedulerRecipientsCount").textContent = "0";
    document.getElementById("recipientsInfoEmpty").style.display = 'block';
    document.getElementById("recipientsInfoSelected").style.display = 'none';
    document.getElementById("schedulerRecipientsList").style.display = 'none';
  }

  function renderRecipientsInfo(recipientsInfo, isManual = false) {
    if (!recipientsInfo || recipientsInfo.length === 0) {
      if (isManual) {
        return '';
      }
      return '<p><strong>Получатели:</strong> <span class="text-muted">Информация недоступна (старая задача)</span></p>';
    }
    
    let html = '<p><strong>Получатели (в порядке отправки):</strong></p><ul class="list-group list-group-flush small" style="max-height: 200px; overflow-y: auto;">';
    let orderNum = 1;
    recipientsInfo.forEach(function(recipient) {
      let icon = 'bi-person';
      let badgeClass = 'bg-secondary';
      let typeName = 'Контакт';
      
      if (recipient.type === 'group') {
        icon = 'bi-people-fill';
        badgeClass = 'bg-primary';
        typeName = 'Группа';
      } else if (recipient.type === 'channel') {
        icon = 'bi-broadcast';
        badgeClass = 'bg-info';
        typeName = 'Канал';
      }
      
      let topicInfo = '';
      if (recipient.topic_name) {
        topicInfo = ` <span class="badge bg-warning text-dark"><i class="bi bi-chat-left-text"></i> ${escapeHtml(recipient.topic_name)}</span>`;
      }
      
      let sentAtInfo = '';
      let statusBadge = '';
      let itemClass = '';
      if (recipient.sent_at && recipient.status === 'sent') {
        statusBadge = '<span class="badge bg-success ms-1">Выполнено</span>';
        sentAtInfo = ` <span class="text-muted small"><i class="bi bi-clock"></i> ${formatDate(recipient.sent_at)}</span>`;
        itemClass = 'list-group-item-success';
      } else if (recipient.status === 'failed') {
        statusBadge = '<span class="badge bg-danger ms-1">Ошибка</span>';
        itemClass = 'list-group-item-danger';
      } else {
        statusBadge = '<span class="badge bg-secondary ms-1">Не отправлено</span>';
      }
      
      html += `<li class="list-group-item py-1 px-2 d-flex justify-content-between align-items-center">
        <div>
          <span class="badge bg-dark me-1">${orderNum}</span>
          <i class="bi ${icon} me-1"></i>
          <span>${escapeHtml(recipient.name)}</span>
          <span class="badge ${badgeClass} ms-1">${typeName}</span>
          ${topicInfo}
          ${statusBadge}
        </div>
        ${sentAtInfo}
      </li>`;
      orderNum++;
    });
    html += '</ul>';
    return html;
  }

  async function loadCompletedTasks() {
    try {
      const response = await fetch("/api/scheduler/completed");
      const data = await response.json();

      if (data.success) {
        // Update refresh interval if provided
        if (data.refresh_interval_ms) {
          completedRefreshIntervalMs = data.refresh_interval_ms;
        }
        displayCompletedTasks(data.tasks);
      } else {
        showAlert("Ошибка загрузки выполненных задач: " + data.error, "danger");
      }
    } catch (error) {
      showAlert("Ошибка загрузки выполненных задач: " + error.message, "danger");
    }
  }

  function toggleAutoUpdate(type) {
    if (type === 'active') {
      const checkbox = document.getElementById('autoUpdateActiveCheckbox');
      if (checkbox && checkbox.checked) {
        // Enable auto-update
        if (!activeTasksInterval) {
          activeTasksInterval = setInterval(loadTasks, activeRefreshIntervalMs);
        }
      } else {
        // Disable auto-update
        if (activeTasksInterval) {
          clearInterval(activeTasksInterval);
          activeTasksInterval = null;
        }
      }
    } else if (type === 'completed') {
      const checkbox = document.getElementById('autoUpdateCompletedCheckbox');
      if (checkbox && checkbox.checked) {
        // Enable auto-update
        if (!completedTasksInterval) {
          completedTasksInterval = setInterval(loadCompletedTasks, completedRefreshIntervalMs);
        }
      } else {
        // Disable auto-update
        if (completedTasksInterval) {
          clearInterval(completedTasksInterval);
          completedTasksInterval = null;
        }
      }
    }
  }

  function displayCompletedTasks(tasks) {
    const container = document.getElementById("completedTasksList");

    if (tasks.length === 0) {
      container.innerHTML = '<p class="text-center text-muted py-5">Нет выполненных задач</p>';
      return;
    }

    let html = '<div class="accordion" id="completedTasksAccordion">';

    tasks.forEach((task, index) => {
      // Use the global_order assigned by backend if available
      const displayIndex = task.global_order || (tasks.length - index);
      const messagePreview = task.message_text.length > 50 
        ? task.message_text.substring(0, 50) + "..." 
        : task.message_text;
      
      const recipientsHtml = renderRecipientsStatus(task.recipients_info, true, task.time_slots);
      
      let statusBadge = '';
      let typeBadge = '';
      const tgAccount = task.telegram_username || task.telegram_account || 'Неизвестно';
      
      // Generate display ID (sequential number 1, 2, 3...)
      let displayId = `<strong>#${displayIndex}</strong> - `;
      
      if (task.is_scheduled === false) {
        typeBadge = '<span class="badge bg-info ms-2">Ручная отправка</span>';
        if (task.success_count === 0) {
          statusBadge = '<span class="badge bg-danger ms-2"><i class="bi bi-exclamation-triangle"></i> Ошибка</span>';
        } else if (task.success_count < task.recipients_count) {
          statusBadge = '<span class="badge bg-warning ms-2"><i class="bi bi-exclamation-circle"></i> Частично</span>';
        } else {
          statusBadge = '<span class="badge bg-success ms-2"><i class="bi bi-check-all"></i> Доставлено</span>';
        }
      } else {
        typeBadge = '<span class="badge bg-primary ms-2">Запланированная</span>';
        if (task.status === 'cancelled') {
          statusBadge = '<span class="badge bg-warning text-dark ms-2"><i class="bi bi-x-circle"></i> Отменено</span>';
        } else if (task.status === 'completed' || task.status === 'sent') {
          statusBadge = '<span class="badge bg-success ms-2"><i class="bi bi-check-all"></i> Завершено</span>';
        } else if (task.status === 'failed') {
          statusBadge = '<span class="badge bg-danger ms-2"><i class="bi bi-exclamation-triangle"></i> Ошибка</span>';
        } else {
          statusBadge = `<span class="badge bg-secondary ms-2"><i class="bi bi-hourglass-split"></i> ${task.status}</span>`;
        }
      }

      let successInfo = '';
      if (task.status === 'cancelled') {
        successInfo = `<p><strong>Статус:</strong> <span class="badge bg-warning text-dark"><i class="bi bi-x-circle"></i> Отменено пользователем</span></p>`;
      } else if (task.status === 'failed' && (!task.success_count || task.success_count === 0)) {
        successInfo = `<p><strong>Статус:</strong> <span class="badge bg-danger">Ошибка отправки (проверьте сессию)</span></p>`;
      } else if (task.success_count !== undefined) {
        let badgeColor = 'bg-success';
        let statusText = 'Успешно отправлено';
        if (task.success_count === 0) {
          badgeColor = 'bg-danger';
          statusText = 'Ошибка отправки';
        } else if (task.success_count < task.recipients_count) {
          badgeColor = 'bg-warning';
          statusText = 'Частично отправлено';
        }
        successInfo = `<p><strong>${statusText}:</strong> <span class="badge ${badgeColor}">${task.success_count}/${task.recipients_count}</span></p>`;
      }

      const completedRecipientsHtml = (task.recipients_info && task.recipients_info.length > 0) ? renderRecipientsInfo(task.recipients_info, false) : '<p class="text-muted small">Детальная информация о получателях недоступна</p>';

      // Render time slots if available
      let timeSlotsHtml = '';
      if (task.time_slots && task.time_slots.length > 0) {
        timeSlotsHtml = '<h6 class="mt-3"><i class="bi bi-clock-history"></i> Слоты рассылки:</h6>';
        task.time_slots.forEach(slot => {
          const date = formatDate(slot.datetime);
          let statusBadge = '';
          
          switch(slot.status) {
            case 'pending': statusBadge = '<span class="badge bg-secondary">Ожидает</span>'; break;
            case 'executing': statusBadge = '<span class="badge bg-primary">Выполняется</span>'; break;
            case 'completed': statusBadge = '<span class="badge bg-success">Завершено</span>'; break;
            case 'completed_with_errors': statusBadge = '<span class="badge bg-warning text-dark">С ошибками</span>'; break;
            case 'cancelled': statusBadge = '<span class="badge bg-warning text-dark">Отменено</span>'; break;
            case 'failed': statusBadge = '<span class="badge bg-danger">Ошибка</span>'; break;
            default: statusBadge = `<span class="badge bg-info">${slot.status}</span>`;
          }

          timeSlotsHtml += `
            <div class="mb-2 p-2 border-bottom slot-item" data-slot-id="${slot.id}" style="cursor: pointer; transition: background-color 0.2s;" 
                 onmouseover="this.style.backgroundColor='#f8f9fa'" 
                 onmouseout="this.style.backgroundColor='transparent'"
                 onclick="openSlotDetails(${slot.id})">
              <div class="d-flex justify-content-between align-items-center">
                <small class="text-muted">${date}</small>
                ${statusBadge}
              </div>
            </div>
          `;
        });
      }

      html += `
        <div class="accordion-item">
          <h2 class="accordion-header">
            <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#compTask${task.id}">
              <div class="d-flex justify-content-between align-items-center w-100 me-3">
                <span>
                  <strong>#${task.global_order || task.id}</strong> - ${escapeHtml(messagePreview)}
                  <span class="ms-2 badge bg-secondary" style="font-size: 0.7rem;">${task.telegram_account}</span>
                </span>
                <span class="badge ${task.status === 'completed' ? 'bg-success' : 'bg-warning'}">${task.success_count}/${task.recipients_count}</span>
              </div>
            </button>
          </h2>
          <div id="compTask${task.id}" class="accordion-collapse collapse" data-bs-parent="#completedAccordion">
            <div class="accordion-body">
              <div class="row">
                <div class="col-md-7">
                  <p><strong>Создана:</strong> ${formatDate(task.created_at)}</p>
                  <p><strong>Завершена:</strong> ${formatDate(task.completed_at) || 'N/A'}</p>
                  ${timeSlotsHtml}
                  <h6 class="mt-3"><i class="bi bi-chat-dots"></i> Текст сообщения:</h6>
                  <div class="p-2 bg-light border rounded mb-3" style="white-space: pre-wrap; font-size: 0.9rem;">${escapeHtml(task.message_text)}</div>
                </div>
                <div class="col-md-5 border-start">
                  <h6><i class="bi bi-people"></i> Статус получателей:</h6>
                  <div class="recipients-status-list border rounded p-2 bg-white" style="max-height: 300px; overflow-y: auto;">
                    ${recipientsHtml}
                  </div>
                </div>
              </div>
              <div class="d-flex justify-content-end mt-3">
                <button class="btn btn-sm btn-outline-danger" onclick="deleteTask(${task.id})">
                  <i class="bi bi-trash"></i> Удалить из истории
                </button>
              </div>
            </div>
          </div>
        </div>
      `;
    });

    html += '</div>';
    container.innerHTML = html;
  }

  // Modal functionality for slot details
  let currentSlotId = null;
  let slotUpdateInterval = null;
  let allRecipients = [];
  let currentFilter = 'all';

  async function openSlotDetails(slotId) {
    currentSlotId = slotId;
    currentFilter = 'all';
    
    // Show the modal
    const modal = new bootstrap.Modal(document.getElementById('slotDetailsModal'));
    modal.show();
    
    // Load slot data
    await loadSlotData(slotId);
    
    // Setup filter buttons
    setupFilterButtons();
    
    // Setup auto-refresh for executing slots
    setupAutoRefresh();
    
    // Cleanup on modal close
    document.getElementById('slotDetailsModal').addEventListener('hidden.bs.modal', function () {
      if (slotUpdateInterval) {
        clearInterval(slotUpdateInterval);
        slotUpdateInterval = null;
      }
    }, { once: true });
  }

  async function loadSlotData(slotId) {
    try {
      const response = await fetch(`/api/slot/${slotId}/recipients-status`);
      const data = await response.json();
      
      if (data.success) {
        const slot = data.slot;
        allRecipients = data.recipients;
        
        // Update slot info
        document.getElementById('slotStatus').innerHTML = getStatusBadge(slot.status);
        document.getElementById('slotDateTime').textContent = formatDate(slot.scheduled_datetime);
        document.getElementById('slotProgress').innerHTML = `${slot.processed_recipients}/${slot.total_recipients} (${slot.percentage}%)`;
        
        // Update counts
        updateCounts();
        
        // Render table
        renderRecipientsTable();
        
        // Setup auto-refresh if executing
        if (slot.status === 'executing') {
          if (!slotUpdateInterval) {
            slotUpdateInterval = setInterval(() => loadSlotData(slotId), 2000);
          }
        } else {
          if (slotUpdateInterval) {
            clearInterval(slotUpdateInterval);
            slotUpdateInterval = null;
          }
        }
      } else {
        showAlert('Ошибка загрузки данных слота: ' + data.error, 'danger');
      }
    } catch (error) {
      console.error('Error loading slot data:', error);
      showAlert('Ошибка загрузки данных слота', 'danger');
    }
  }

  function setupFilterButtons() {
    const filterButtons = document.querySelectorAll('[data-filter]');
    filterButtons.forEach(btn => {
      btn.addEventListener('click', function() {
        // Remove active class from all buttons
        filterButtons.forEach(b => b.classList.remove('active'));
        // Add active class to clicked button
        this.classList.add('active');
        // Update filter
        currentFilter = this.getAttribute('data-filter');
        // Re-render table
        renderRecipientsTable();
      });
    });
  }

  function setupAutoRefresh() {
    // Auto-refresh is handled in loadSlotData
  }

  function updateCounts() {
    const counts = {
      all: allRecipients.length,
      sent: 0,
      failed: 0,
      pending: 0,
      cancelled: 0
    };
    
    allRecipients.forEach(r => {
      if (counts[r.status] !== undefined) {
        counts[r.status]++;
      }
    });
    
    document.getElementById('countAll').textContent = counts.all;
    document.getElementById('countSent').textContent = counts.sent;
    document.getElementById('countFailed').textContent = counts.failed;
    document.getElementById('countPending').textContent = counts.pending;
    document.getElementById('countCancelled').textContent = counts.cancelled;
  }

  function renderRecipientsTable() {
    const tbody = document.getElementById('recipientsTable');
    
    // Filter recipients
    let filteredRecipients = allRecipients;
    if (currentFilter !== 'all') {
      filteredRecipients = allRecipients.filter(r => r.status === currentFilter);
    }
    
    if (filteredRecipients.length === 0) {
      tbody.innerHTML = '<tr><td colspan="4" class="text-center text-muted">Нет данных</td></tr>';
      return;
    }
    
    let html = '';
    filteredRecipients.forEach(r => {
      const statusBadge = getRecipientStatusBadge(r.status);
      const sentAt = r.sent_at ? formatDate(r.sent_at) : '-';
      const errorMsg = r.error_message ? escapeHtml(r.error_message) : '-';
      const errorTitle = r.error_message ? ` title="${escapeHtml(r.error_message)}"` : '';
      
      html += `
        <tr>
          <td>${escapeHtml(r.name)}</td>
          <td>${statusBadge}</td>
          <td>${sentAt}</td>
          <td${errorTitle} style="max-width: 500px; word-break: break-word; white-space: normal;">${errorMsg}</td>
        </tr>
      `;
    });
    
    tbody.innerHTML = html;
  }

  function getStatusBadge(status) {
    const badges = {
      'pending': '<span class="badge bg-secondary">Ожидает</span>',
      'executing': '<span class="badge bg-primary">Выполняется</span>',
      'completed': '<span class="badge bg-success">Завершено</span>',
      'completed_with_errors': '<span class="badge bg-warning text-dark">Завершено с ошибками</span>',
      'cancelled': '<span class="badge bg-warning text-dark">Отменено</span>',
      'failed': '<span class="badge bg-danger">Ошибка</span>'
    };
    return badges[status] || `<span class="badge bg-info">${status}</span>`;
  }

  function getRecipientStatusBadge(status) {
    const badges = {
      'sent': '<span class="badge bg-success">✅ Отправлено</span>',
      'failed': '<span class="badge bg-danger">❌ Ошибка</span>',
      'pending': '<span class="badge bg-warning">⏳ Ожидает</span>',
      'cancelled': '<span class="badge bg-secondary">⭕ Отменено</span>'
    };
    return badges[status] || `<span class="badge bg-info">${status}</span>`;
  }
</script>
{% endblock %}
